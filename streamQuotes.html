<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/metaapi.cloud-sdk/index.js"></script>
    <style>
      table,
      th,
      td {
        border: 1px solid gray;
        border-collapse: collapse;
      }
      td {
        text-align: right;
      }
    </style>
    <title>stream quotes demo</title>
  </head>
  <body>
    <script>
      class SynchronizationListener {
        /**
         * Returns instance number of instance index
         * @param {String} instanceIndex instance index
         */
        getInstanceNumber(instanceIndex) {
          return typeof instanceIndex === 'string'
            ? Number(instanceIndex.split(':')[0])
            : undefined;
        }

        /**
         * Returns host name of instance index
         * @param {String} instanceIndex instance index
         */
        getHostName(instanceIndex) {
          return typeof instanceIndex === 'string'
            ? instanceIndex.split(':')[1]
            : undefined;
        }

        /**
         * Invoked when connection to MetaTrader terminal established
         * @param {String} instanceIndex index of an account instance connected
         * @param {Number} replicas number of account replicas launched
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onConnected(instanceIndex, replicas) {}

        /**
         * Server-side application health status
         * @typedef {Object} healthStatus
         * @property {boolean} [restApiHealthy] flag indicating that REST API is healthy
         * @property {boolean} [copyFactorySubscriberHealthy] flag indicating that CopyFactory subscriber is healthy
         * @property {boolean} [copyFactoryProviderHealthy] flag indicating that CopyFactory provider is healthy
         */

        /**
         * Invoked when a server-side application health status is received from MetaApi
         * @param {String} instanceIndex index of an account instance connected
         * @param {HealthStatus} status server-side application health status
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onHealthStatus(instanceIndex, status) {}

        /**
         * Invoked when connection to MetaTrader terminal terminated
         * @param {String} instanceIndex index of an account instance connected
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onDisconnected(instanceIndex) {}

        /**
         * Invoked when broker connection satus have changed
         * @param {String} instanceIndex index of an account instance connected
         * @param {Boolean} connected is MetaTrader terminal is connected to broker
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onBrokerConnectionStatusChanged(instanceIndex, connected) {}

        /**
         * Invoked when MetaTrader terminal state synchronization is started
         * @param {String} instanceIndex index of an account instance connected
         * @param {Boolean} specificationsUpdated whether specifications are going to be updated during synchronization
         * @param {Boolean} positionsUpdated whether positions are going to be updated during synchronization
         * @param {Boolean} ordersUpdated whether orders are going to be updated during synchronization
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSynchronizationStarted(
          instanceIndex,
          specificationsUpdated,
          positionsUpdated,
          ordersUpdated
        ) {}

        /**
         * Invoked when MetaTrader account information is updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onAccountInformationUpdated(instanceIndex, accountInformation) {}

        /**
         * Invoked when the positions are replaced as a result of initial terminal state synchronization. This method
         * will be invoked only if server thinks the data was updated, otherwise invocation can be skipped
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderPosition>} positions updated array of positions
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPositionsReplaced(instanceIndex, positions) {}

        /**
         * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
         * @param {string} instanceIndex index of an account instance connected
         * @param {String} synchronizationId synchronization request id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPositionsSynchronized(instanceIndex, synchronizationId) {}

        /**
         * Invoked when MetaTrader position is updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderPosition} position updated MetaTrader position
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPositionUpdated(instanceIndex, position) {}

        /**
         * Invoked when MetaTrader position is removed
         * @param {String} instanceIndex index of an account instance connected
         * @param {String} positionId removed MetaTrader position id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPositionRemoved(instanceIndex, positionId) {}

        /**
         * Invoked when the pending orders are replaced as a result of initial terminal state synchronization. This method
         * will be invoked only if server thinks the data was updated, otherwise invocation can be skipped
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderOrder>} orders updated array of pending orders
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPendingOrdersReplaced(instanceIndex, orders) {}

        /**
         * Invoked when MetaTrader pending order is updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderOrder} order updated MetaTrader pending order
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPendingOrderUpdated(instanceIndex, order) {}

        /**
         * Invoked when MetaTrader pending order is completed (executed or canceled)
         * @param {String} instanceIndex index of an account instance connected
         * @param {String} orderId completed MetaTrader pending order id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPendingOrderCompleted(instanceIndex, orderId) {}

        /**
         * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
         * synchronization
         * @param {string} instanceIndex index of an account instance connected
         * @param {String} synchronizationId synchronization request id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onPendingOrdersSynchronized(instanceIndex, synchronizationId) {}

        /**
         * Invoked when a new MetaTrader history order is added
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderOrder} historyOrder new MetaTrader history order
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onHistoryOrderAdded(instanceIndex, historyOrder) {}

        /**
         * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
         * initial terminal state synchronization
         * @param {String} instanceIndex index of an account instance connected
         * @param {String} synchronizationId synchronization request id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {}

        /**
         * Invoked when a new MetaTrader history deal is added
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderDeal} deal new MetaTrader history deal
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onDealAdded(instanceIndex, deal) {}

        /**
         * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
         * initial terminal state synchronization
         * @param {String} instanceIndex index of an account instance connected
         * @param {String} synchronizationId synchronization request id
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onDealsSynchronized(instanceIndex, synchronizationId) {}

        /**
         * Invoked when a symbol specification was updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderSymbolSpecification} specification updated MetaTrader symbol specification
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSymbolSpecificationUpdated(instanceIndex, specification) {}

        /**
         * Invoked when a symbol specification was removed
         * @param {String} instanceIndex index of an account instance connected
         * @param {String} symbol removed symbol
         * @returns {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSymbolSpecificationRemoved(instanceIndex, symbol) {}

        /**
         * Invoked when a symbol specifications were updated
         * @param {String} instanceIndex index of account instance connected
         * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
         * @param {Array<String>} removedSymbols removed symbols
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSymbolSpecificationsUpdated(
          instanceIndex,
          specifications,
          removedSymbols
        ) {}

        /**
         * Invoked when a symbol price was updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {MetatraderSymbolPrice} price updated MetaTrader symbol price
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSymbolPriceUpdated(instanceIndex, price) {}

        /**
         * Invoked when prices for several symbols were updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
         * @param {Number} equity account liquidation value
         * @param {Number} margin margin used
         * @param {Number} freeMargin free margin
         * @param {Number} marginLevel margin level calculated as % of equity/margin
         * @param {Number} accountCurrencyExchangeRate current exchange rate of account currency into USD
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSymbolPricesUpdated(
          instanceIndex,
          prices,
          equity,
          margin,
          freeMargin,
          marginLevel,
          accountCurrencyExchangeRate
        ) {}

        /**
         * Invoked when symbol candles were updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderCandle>} candles updated MetaTrader symbol candles
         * @param {Number} equity account liquidation value
         * @param {Number} margin margin used
         * @param {Number} freeMargin free margin
         * @param {Number} marginLevel margin level calculated as % of equity/margin
         * @param {Number} accountCurrencyExchangeRate current exchange rate of account currency into USD
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onCandlesUpdated(
          instanceIndex,
          candles,
          equity,
          margin,
          freeMargin,
          marginLevel,
          accountCurrencyExchangeRate
        ) {}

        /**
         * Invoked when symbol ticks were updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderTick>} ticks updated MetaTrader symbol ticks
         * @param {Number} equity account liquidation value
         * @param {Number} margin margin used
         * @param {Number} freeMargin free margin
         * @param {Number} marginLevel margin level calculated as % of equity/margin
         * @param {Number} accountCurrencyExchangeRate current exchange rate of account currency into USD
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onTicksUpdated(
          instanceIndex,
          ticks,
          equity,
          margin,
          freeMargin,
          marginLevel,
          accountCurrencyExchangeRate
        ) {}

        /**
         * Invoked when order books were updated
         * @param {String} instanceIndex index of an account instance connected
         * @param {Array<MetatraderBook>} books updated MetaTrader order books
         * @param {Number} equity account liquidation value
         * @param {Number} margin margin used
         * @param {Number} freeMargin free margin
         * @param {Number} marginLevel margin level calculated as % of equity/margin
         * @param {Number} accountCurrencyExchangeRate current exchange rate of account currency into USD
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onBooksUpdated(
          instanceIndex,
          books,
          equity,
          margin,
          freeMargin,
          marginLevel,
          accountCurrencyExchangeRate
        ) {}

        /**
         * Invoked when subscription downgrade has occurred
         * @param {String} instanceIndex index of an account instance connected
         * @param {string} symbol symbol to update subscriptions for
         * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
         * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
         * @return {Promise} promise which resolves when the asynchronous event is processed
         */
        async onSubscriptionDowngraded(
          instanceIndex,
          symbol,
          updates,
          unsubscriptions
        ) {}

        /**
         * Invoked when a stream for an instance index is closed
         * @param {String} instanceIndex index of an account instance connected
         */
        async onStreamClosed(instanceIndex) {}
      }
    </script>
    <script>
      const accounts = [
        {
          token:
            'eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI0N2ZkOWUyZjY5OWM5NDczNjc2MjBlZGQzMmY5N2IyMiIsInBlcm1pc3Npb25zIjpbXSwidG9rZW5JZCI6IjIwMjEwMjEzIiwiaWF0IjoxNjQyMzgyMDQ5LCJyZWFsVXNlcklkIjoiNDdmZDllMmY2OTljOTQ3MzY3NjIwZWRkMzJmOTdiMjIifQ.KCcJ1U0p6xHn2V5wdcUatqiBiguY5iSAHe5IdffrJI7ICcSlq4hrcbC6mapp2mt4ghyoJG7v-Dd7bRBkzojzAsF4FP7qJGR9ow1sRvRT9rW4igTPCXdpblJOPpXl7phwAXPoItgJO-mlWR-y6cjV6VOPTdew5ruUwgyfBez7JecijCTuNVWoLWG4nxAJJPZBeAwbidrl80fRwIO1KJux4owAY4rXj2zMTQKe8PMKCPLu1Ybd03HGu-EESEJ4juDaO9bYzxLcsmOj26bpV2kScjEVy0FTGVwmegQWsyPeiBdmfAT2zX7b36RrI7OJAJ_eYtGx08ntRJRlxH0eUq1TY21FBHhnkk2AEnBBREMinXryGlSO5zldbkULiGts163R4CLiHcz7ua_MVrEMQQW8ho3ZF_dRy-rYa9PnRC-pPbQXa-pX7KAELtqLtN_9BbQfdPBpQ_a3oJdobW65-osMgO3NdIoOdhSZIVBTfYxzPqtVwKA_64g9ptG-QXNF5-8-vs1XySHADUEccesFgbRQiV-GY5BfpTqIU_sedmYIfdPLSOk_kRZMa9AOhofhLKSOx737iypfLNHGpUWimaYiuzcgS9eTRd8ZwCs7SOdRVk2-hfjVGt3kgMtdSu1Fe0hFU1aHcAhr3I_qY-R-thchV6tgM8OFUU4G1I-vhMT215U',
          accountId: 'e8767469-7cdf-40a0-a387-cddd9f592fe8'
        },
        {
          token:
            'eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI3MzcyOTEyZjk1ZmU1ODhlZDk1Y2NjOGE5MDMyMWMzMiIsInBlcm1pc3Npb25zIjpbXSwidG9rZW5JZCI6IjIwMjEwMjEzIiwiaWF0IjoxNjQyMzg1NTg4LCJyZWFsVXNlcklkIjoiNzM3MjkxMmY5NWZlNTg4ZWQ5NWNjYzhhOTAzMjFjMzIifQ.RluUJ8j9fbLigg1hkFF7RXjMaGokOASBO5_AE_zlBRkH4bOVsp-N0ysWMYPkMmvpxA1_NONsYVdLInuHcYnniyksU7LDuaFg4477bmBDT7mcRu9EkoL2za9pLwmyfnJNjXhcpF3ko8WtpnLWGkit2DM6F6TZTRob6o44Fnos5-vRbHIV4hxmUogDSVONP1VlyxJmYLnJA-6aw6CV-7vugg_-ytSII4wd0390qf8Mk4p2gtSUDzehLjwb3Iq875KWoeTNn7R-bB_XyXw8xFNuHxUJTz8i7lx3jglTC9-ijyWOR39Nx8O3sUJt52UL__i_aa1pBxjFORKxVQBOJfZbc_JyaPLIAyqgy7wRtt_kVwptV_1tsqFW2aB_FBoH0zrVRV-yGOOUWINGPW7TtChmDyKy0ZBtnEa9S3TPkE5hbdQVF-ZCvBVvfWByw-EWFWClQWAs_TNqPLojFKdxhVGQ894-8_8CcRSVp1WTBIXsuD54PRAK16QcxKiWYAJfw6KYnZtz4X8HlBKY_DpVOn8RhmmRUkqEKBfwW8OL5cjeObJyan-gxxVj6fDuwF3bMmtC7fy8lZNT66SSRoxwJFc586m9wTLRQgelrYETxnty8Xt7XqOCVroKA36DBPh837sAMAHkvlnbHTxtSm7_xDuR5E6BOh_78lzzbVPYlTzeS9M',
          accountId: '6a18da63-cf9b-4fc9-ad26-37b7819aceee'
        }
      ];

      let symbols = ['GBPUSD', 'EURUSD', 'USDJPY', 'USDCAD', 'AUDUSD'];

      let output = [];

      function roundToFive(num) {
        return +(Math.round(num + 'e+5') + 'e-5');
      }

      function updateLayout() {
        const companies = output
          .map((x) => `<th colspan="2">${x.server}</th>`)
          .join('');
        const types = '<th>Bid</th><th>Ask</th>';

        const infos = symbols.map(
          (symbol) => `<tr>
        <th>${symbol}</th>
        ${output.map((x) => {
          const thisSymbol = x.symbols.find((each) => each.symbol === symbol);
          return `<td>${thisSymbol.bid}</td><td>${thisSymbol.ask}</td>`;
        })}
        </tr>`
        );

        document.getElementById(
          'result'
        ).innerHTML = `<table style="width:100%">
        <tr>
          <th rowspan="2">Symbols</th>
          ${companies}
        </tr>
        <tr>
          ${types.repeat(output.length)}
        </tr>
        ${infos}
      </table>`;
      }

      // eslint-disable-next-line
      async function streamQuotes() {
        try {
          for (let i = 0; i < accounts.length; i++) {
            const api = new MetaApi(accounts[i]['token']);

            let account = await api.metatraderAccountApi.getAccount(
              accounts[i]['accountId']
            );

            // wait until account is deployed and connected to broker
            console.log('Deploying account');
            if (account.state !== 'DEPLOYED') {
              await account.deploy();
            } else {
              console.log('Account already deployed');
            }
            console.log(
              'Waiting for API server to connect to broker (may take couple of minutes)'
            );
            if (account.connectionStatus !== 'CONNECTED') {
              await account.waitConnected();
            }

            // create connection
            let connection = account.getStreamingConnection();

            for (let j = 0; j < symbols.length; j++) {
              const symbol = symbols[j];

              class QuoteListener extends SynchronizationListener {
                async onSymbolPriceUpdated(instanceIndex, price) {
                  if (instanceIndex && output.length) {
                    const thisServer = output.find(
                      (x) => x.host === instanceIndex
                    );
                    if (thisServer) {
                      output = output.map((x) => {
                        if (x.host === instanceIndex) {
                          return {
                            ...x,
                            symbols: x.symbols.map((y) => {
                              if (y.symbol === price.symbol) {
                                return {
                                  symbol: price.symbol,
                                  bid: roundToFive(price.bid),
                                  ask: roundToFive(price.ask)
                                };
                              } else {
                                return y;
                              }
                            })
                          };
                        } else {
                          return x;
                        }
                      });

                      console.log(
                        `${thisServer.server} === ${instanceIndex} === ${price.symbol}`
                      );

                      updateLayout();
                    }
                  }
                }
              }

              // add listener
              const quoteListener = new QuoteListener();
              connection.addSynchronizationListener(quoteListener);

              // connect to MetaApi API
              await connection.connect();

              await connection.waitSynchronized();

              await connection.subscribeToMarketData(symbol, []);

              const terminalState = connection.terminalState;

              const info = terminalState['_stateByInstanceIndex'];

              const key = Object.keys(info)[0];

              const { accountInformation, instanceIndex, pricesBySymbol } =
                info[key];

              const keys = Object.keys(pricesBySymbol);

              if (keys.length === symbols.length) {
                const server = accountInformation.server;
                const host = instanceIndex;

                const data = symbols.map((symbol) => {
                  if (keys.includes(symbol)) {
                    return {
                      symbol: pricesBySymbol[symbol].symbol,
                      bid: roundToFive(pricesBySymbol[symbol].bid),
                      ask: roundToFive(pricesBySymbol[symbol].ask)
                    };
                  }
                });

                let thisHost = output.find((x) => x.host === host);
                if (thisHost) {
                  thisHost = { server, host, symbols: data };
                } else {
                  const newData = { server, host, symbols: data };
                  output.push(newData);
                }

                console.log(`----------${server}-----------`);
              }
            }
          }
        } catch (err) {
          console.error('err', err);
        }
      }

      streamQuotes();
    </script>
    <div id="result"></div>
    <script></script>
  </body>
</html>
